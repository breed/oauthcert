package com.homeofcode.wgkeyman;

import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.ASN1OctetString;
import org.bouncycastle.asn1.x500.RDN;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x500.style.BCStyle;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.operator.ContentVerifierProvider;
import org.bouncycastle.operator.jcajce.JcaContentVerifierProviderBuilder;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.security.cert.X509Certificate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class CertificateService {

    private static final ASN1ObjectIdentifier WG_PUBLIC_KEY_OID =
            new ASN1ObjectIdentifier("1.3.6.1.4.1.99999.1");

    private final WgKeymanConfig config;

    // Track the latest certificate issue date for each user to prevent replay of old certificates
    private final ConcurrentHashMap<String, Date> latestCertDate = new ConcurrentHashMap<>();

    // Track peers (CN -> public key) for the WireGuard config
    private final Map<String, String> peers = new LinkedHashMap<>();

    public CertificateService(WgKeymanConfig config) {
        this.config = config;
        loadCertDates();
        loadPeers();
    }

    private Path getCertDatesPath() {
        return Path.of(config.getCertDatesFile());
    }

    private void loadCertDates() {
        Path path = getCertDatesPath();
        if (!Files.exists(path)) {
            return;
        }
        try {
            for (String line : Files.readAllLines(path)) {
                line = line.trim();
                if (line.isEmpty() || line.startsWith("#")) {
                    continue;
                }
                String[] parts = line.split("\\s+", 2);
                if (parts.length == 2) {
                    try {
                        long timestamp = Long.parseLong(parts[0]);
                        String cn = parts[1];
                        latestCertDate.put(cn, new Date(timestamp));
                    } catch (NumberFormatException e) {
                        // Skip invalid lines
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Warning: Could not load certificate dates from " + path + ": " + e.getMessage());
        }
    }

    private synchronized void saveCertDates() {
        Path path = getCertDatesPath();
        StringBuilder sb = new StringBuilder();
        sb.append("# Certificate issue dates (timestamp CN)\n");
        for (var entry : latestCertDate.entrySet()) {
            sb.append(entry.getValue().getTime()).append(" ").append(entry.getKey()).append("\n");
        }
        try {
            Files.writeString(path, sb.toString());
        } catch (IOException e) {
            System.err.println("Warning: Could not save certificate dates to " + path + ": " + e.getMessage());
        }
    }

    private static final String WG_KEYMAN_MARKER = "# Generated by wg-keyman";

    private Path getPeersPath() {
        return Path.of(config.getPeersFile());
    }

    // Stores manually-added peer sections (not managed by wg-keyman)
    private final List<String> manualPeerSections = new ArrayList<>();

    private void loadPeers() {
        Path path = getPeersPath();
        if (!Files.exists(path)) {
            return;
        }
        try {
            List<String> lines = Files.readAllLines(path);
            StringBuilder currentSection = new StringBuilder();
            boolean inPeerSection = false;
            boolean isWgKeymanManaged = false;
            String currentCn = null;

            for (String line : lines) {
                String trimmed = line.trim();

                if (trimmed.equals("[Peer]")) {
                    // Save previous section if it was manual
                    if (inPeerSection && !isWgKeymanManaged && currentSection.length() > 0) {
                        manualPeerSections.add(currentSection.toString());
                    }
                    // Start new section
                    currentSection = new StringBuilder();
                    currentSection.append(line).append("\n");
                    inPeerSection = true;
                    isWgKeymanManaged = false;
                    currentCn = null;
                } else if (inPeerSection) {
                    currentSection.append(line).append("\n");

                    if (trimmed.startsWith(WG_KEYMAN_MARKER)) {
                        isWgKeymanManaged = true;
                    } else if (trimmed.startsWith("# ") && trimmed.contains("@") && isWgKeymanManaged) {
                        // CN line for wg-keyman managed peer
                        currentCn = trimmed.substring(2).trim();
                    } else if (trimmed.startsWith("PublicKey = ") && currentCn != null) {
                        String publicKey = trimmed.substring("PublicKey = ".length()).trim();
                        peers.put(currentCn, publicKey);
                        currentCn = null;
                    }
                } else {
                    // Lines before any [Peer] section (header comments, etc.)
                    if (!trimmed.isEmpty()) {
                        // Store as part of manual content at the start
                        if (manualPeerSections.isEmpty() || !manualPeerSections.get(0).startsWith("[Peer]")) {
                            if (manualPeerSections.isEmpty()) {
                                manualPeerSections.add(line + "\n");
                            } else {
                                manualPeerSections.set(0, manualPeerSections.get(0) + line + "\n");
                            }
                        }
                    }
                }
            }

            // Don't forget the last section
            if (inPeerSection && !isWgKeymanManaged && currentSection.length() > 0) {
                manualPeerSections.add(currentSection.toString());
            }
        } catch (IOException e) {
            System.err.println("Warning: Could not load peers from " + path + ": " + e.getMessage());
        }
    }

    /**
     * Save peers to config file and sync WireGuard.
     * Preserves any peer sections that were not generated by wg-keyman.
     * @return warning message if there was a problem, null if successful
     */
    private synchronized String savePeers() {
        Path path = getPeersPath();

        // Backup old config if it exists
        backupOldConfig(path);

        // Build new peers config
        StringBuilder sb = new StringBuilder();

        // First, write any manual peer sections (preserving non-wg-keyman managed peers)
        for (String section : manualPeerSections) {
            sb.append(section);
            if (!section.endsWith("\n\n")) {
                sb.append("\n");
            }
        }

        // Then write wg-keyman managed peers
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        for (var entry : peers.entrySet()) {
            String cn = entry.getKey();
            String publicKey = entry.getValue();
            Integer hostNumber = config.getUserHostNumbers().get(cn);
            if (hostNumber != null) {
                String allowedIps = config.getClientAddress(hostNumber);
                sb.append("[Peer]\n");
                sb.append(WG_KEYMAN_MARKER).append(" on ").append(timestamp).append("\n");
                sb.append("# ").append(cn).append("\n");
                sb.append("PublicKey = ").append(publicKey).append("\n");
                sb.append("AllowedIPs = ").append(allowedIps).append("\n");
                sb.append("\n");
            }
        }
        try {
            Files.writeString(path, sb.toString());
            System.out.println("Saved peers config to " + path);

            // Sync WireGuard config
            return syncWireguardConfig();
        } catch (IOException e) {
            String warning = "Could not save peers config: " + e.getMessage();
            System.err.println("Warning: " + warning);
            return warning;
        }
    }

    /**
     * Backup the old peers config file by appending .old extension.
     * The old entries are commented out with a timestamp.
     */
    private void backupOldConfig(Path path) {
        if (!Files.exists(path)) {
            return;
        }
        try {
            Path oldPath = Path.of(path.toString() + ".old");
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);

            // Read old config and comment it out
            String oldContent = Files.readString(path);
            StringBuilder backup = new StringBuilder();

            // Add header with timestamp
            backup.append("# Archived on ").append(timestamp).append("\n");

            // Comment out each line
            for (String line : oldContent.split("\n")) {
                if (!line.startsWith("#")) {
                    backup.append("# ");
                }
                backup.append(line).append("\n");
            }
            backup.append("\n");

            // Append to .old file (or create if doesn't exist)
            if (Files.exists(oldPath)) {
                String existingBackup = Files.readString(oldPath);
                backup.insert(0, existingBackup);
            }
            Files.writeString(oldPath, backup.toString());
            System.out.println("Backed up old config to " + oldPath);
        } catch (IOException e) {
            System.err.println("Warning: Could not backup old config: " + e.getMessage());
        }
    }

    /**
     * Sync the WireGuard configuration using wg-quick strip and wg syncconf.
     * Uses 'sudo wg syncconf <interface> <(wg-quick strip <peers-file>)' by default.
     * @return warning message if there was a problem, null if successful
     */
    private String syncWireguardConfig() {
        String syncCommand = config.getSyncCommand();
        String wgInterface = config.getWgInterface();
        String peersFile = config.getPeersFile();

        // If no custom sync command, use wg-quick strip with wg syncconf
        String[] command;
        if (syncCommand == null || syncCommand.trim().isEmpty()) {
            // Use absolute paths and bash process substitution for wg-quick strip
            String absolutePeersFile = Path.of(peersFile).toAbsolutePath().toString();
            String bashCommand = "sudo /usr/bin/wg syncconf " + wgInterface +
                    " <(/usr/bin/wg-quick strip " + absolutePeersFile + ")";
            command = new String[]{"bash", "-c", bashCommand};
        } else {
            // Custom command - split by spaces (simple parsing)
            command = syncCommand.split("\\s+");
        }

        try {
            System.out.println("Running: " + String.join(" ", command));
            ProcessBuilder pb = new ProcessBuilder(command);
            pb.redirectErrorStream(true);
            Process process = pb.start();

            // Read output
            StringBuilder output = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    System.out.println("wg: " + line);
                    output.append(line).append("\n");
                }
            }

            int exitCode = process.waitFor();
            if (exitCode == 0) {
                System.out.println("WireGuard config synced successfully");
                return null;
            } else {
                String warning = "WireGuard sync command failed (exit code " + exitCode + ")";
                if (output.length() > 0) {
                    warning += ": " + output.toString().trim();
                }
                System.err.println("Warning: " + warning);
                return warning;
            }
        } catch (IOException e) {
            String warning = "Could not run WireGuard sync command: " + e.getMessage();
            System.err.println("Warning: " + warning);
            return warning;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            String warning = "WireGuard sync command was interrupted";
            System.err.println("Warning: " + warning);
            return warning;
        }
    }

    /**
     * Parse a PEM-encoded certificate.
     */
    public X509CertificateHolder parseCertificate(String pemContent) throws Exception {
        try (var reader = new StringReader(pemContent);
             var pemParser = new PEMParser(reader)) {
            Object obj = pemParser.readObject();
            if (obj instanceof X509CertificateHolder) {
                return (X509CertificateHolder) obj;
            }
            throw new IllegalArgumentException("Invalid certificate format");
        }
    }

    /**
     * Validate that the certificate was signed by our CA.
     */
    public boolean validateCertificate(X509CertificateHolder cert) throws Exception {
        X509CertificateHolder caCert = config.getCaCert();

        // Convert CA cert to X509Certificate for verification
        JcaX509CertificateConverter converter = new JcaX509CertificateConverter();
        X509Certificate caCertX509 = converter.getCertificate(caCert);

        // Create content verifier from CA's public key
        ContentVerifierProvider verifierProvider = new JcaContentVerifierProviderBuilder()
                .build(caCertX509.getPublicKey());

        return cert.isSignatureValid(verifierProvider);
    }

    /**
     * Extract the Common Name (CN) from the certificate subject.
     */
    public String extractCommonName(X509CertificateHolder cert) {
        X500Name subject = cert.getSubject();
        RDN[] rdns = subject.getRDNs(BCStyle.CN);
        if (rdns.length > 0) {
            return rdns[0].getFirst().getValue().toString();
        }
        return null;
    }

    /**
     * Extract the wireguard public key from the certificate extension.
     * The extension value is stored as an OCTET STRING containing the raw 32-byte public key.
     */
    public String extractWireguardPublicKey(X509CertificateHolder cert) {
        Extension ext = cert.getExtension(WG_PUBLIC_KEY_OID);
        if (ext == null) {
            return null;
        }
        // Get the raw bytes directly from the extension value (OCTET STRING)
        byte[] wgPublicKey = ext.getExtnValue().getOctets();
        return Base64.getEncoder().encodeToString(wgPublicKey);
    }

    /**
     * Check if the CN is in the authorized users list.
     */
    public boolean isAuthorizedUser(String cn) {
        return config.getUserHostNumbers().containsKey(cn);
    }

    /**
     * Get the host number for a user.
     */
    public Integer getHostNumber(String cn) {
        return config.getUserHostNumbers().get(cn);
    }

    /**
     * Generate the wireguard configuration for a client.
     */
    public String generateWireguardConfig(String cn, String clientPublicKey) {
        Integer hostNumber = getHostNumber(cn);
        if (hostNumber == null) {
            throw new IllegalArgumentException("User not found: " + cn);
        }

        String clientAddress = config.getClientAddress(hostNumber);

        StringBuilder config = new StringBuilder();
        config.append("[Interface]\n");
        config.append("# Add your private key below\n");
        config.append("# PrivateKey = <YOUR_PRIVATE_KEY>\n");
        config.append("Address = ").append(clientAddress).append("\n");
        config.append("\n");
        config.append("[Peer]\n");
        config.append("PublicKey = ").append(this.config.getServerPublicKey()).append("\n");
        config.append("Endpoint = ").append(this.config.getServerEndpoint()).append("\n");
        config.append("AllowedIPs = ").append(this.config.getAllowedIps()).append("\n");
        config.append("PersistentKeepalive = 25\n");

        return config.toString();
    }

    /**
     * Validate that a string is a valid WireGuard public key.
     * A valid key is a 32-byte Curve25519 public key, base64-encoded (44 characters ending with =).
     * @return null if valid, error message if invalid
     */
    public String validateWireguardPublicKey(String publicKey) {
        if (publicKey == null || publicKey.trim().isEmpty()) {
            return "Public key is required";
        }
        publicKey = publicKey.trim();

        // WireGuard public keys are exactly 44 characters (32 bytes base64-encoded)
        if (publicKey.length() != 44) {
            return "Invalid WireGuard public key: must be exactly 44 characters";
        }

        // Must end with = (32 bytes = 256 bits, base64 encodes to 43 chars + 1 padding)
        if (!publicKey.endsWith("=")) {
            return "Invalid WireGuard public key: must end with '='";
        }

        // Validate base64 format and decode
        try {
            byte[] decoded = Base64.getDecoder().decode(publicKey);
            if (decoded.length != 32) {
                return "Invalid WireGuard public key: must decode to exactly 32 bytes";
            }
        } catch (IllegalArgumentException e) {
            return "Invalid WireGuard public key: not valid base64";
        }

        return null; // Valid
    }

    /**
     * Process a public key for an OAuth-authenticated user.
     * This is used by the /wg endpoint where the user is authenticated via OAuth
     * and supplies their public key directly.
     */
    public CertificateResult processPublicKey(String email, String publicKey) {
        // Check authorization
        if (!isAuthorizedUser(email)) {
            return CertificateResult.error("User '" + email + "' is not authorized");
        }

        // Validate public key format
        String validationError = validateWireguardPublicKey(publicKey);
        if (validationError != null) {
            return CertificateResult.error(validationError);
        }
        publicKey = publicKey.trim();

        // Generate config
        String wgConfig = generateWireguardConfig(email, publicKey);

        // Update the WireGuard peers config with the new public key
        peers.put(email, publicKey);
        String warning = savePeers();

        if (warning != null) {
            return CertificateResult.successWithWarning(email, publicKey, wgConfig, warning);
        }
        return CertificateResult.success(email, publicKey, wgConfig);
    }

    /**
     * Result of processing a certificate upload.
     */
    public record CertificateResult(
            boolean valid,
            String errorMessage,
            String warningMessage,
            String commonName,
            String wireguardPublicKey,
            String wireguardConfig
    ) {
        public static CertificateResult error(String message) {
            return new CertificateResult(false, message, null, null, null, null);
        }

        public static CertificateResult success(String cn, String wgPublicKey, String wgConfig) {
            return new CertificateResult(true, null, null, cn, wgPublicKey, wgConfig);
        }

        public static CertificateResult successWithWarning(String cn, String wgPublicKey, String wgConfig, String warning) {
            return new CertificateResult(true, null, warning, cn, wgPublicKey, wgConfig);
        }
    }

    /**
     * Process an uploaded certificate and return the result.
     */
    public CertificateResult processCertificate(String pemContent) {
        try {
            // Parse the certificate
            X509CertificateHolder cert = parseCertificate(pemContent);

            // Validate signature
            if (!validateCertificate(cert)) {
                return CertificateResult.error("Certificate was not signed by the trusted CA");
            }

            // Extract CN
            String cn = extractCommonName(cert);
            if (cn == null) {
                return CertificateResult.error("Certificate does not contain a Common Name");
            }

            // Check authorization
            if (!isAuthorizedUser(cn)) {
                return CertificateResult.error("User '" + cn + "' is not authorized");
            }

            // Check certificate is not older than a previously uploaded certificate
            Date certDate = cert.getNotBefore();
            Date previousDate = latestCertDate.get(cn);
            if (previousDate != null && certDate.before(previousDate)) {
                return CertificateResult.error("Certificate is too old. A newer certificate was previously uploaded for this user.");
            }

            // Extract wireguard public key
            String wgPublicKey = extractWireguardPublicKey(cert);
            if (wgPublicKey == null) {
                return CertificateResult.error("Certificate does not contain a wireguard public key extension");
            }

            // Generate config
            String wgConfig = generateWireguardConfig(cn, wgPublicKey);

            // Update the latest certificate date for this user
            latestCertDate.put(cn, certDate);
            saveCertDates();

            // Update the WireGuard peers config with the new public key
            peers.put(cn, wgPublicKey);
            String warning = savePeers();

            if (warning != null) {
                return CertificateResult.successWithWarning(cn, wgPublicKey, wgConfig, warning);
            }
            return CertificateResult.success(cn, wgPublicKey, wgConfig);

        } catch (Exception e) {
            return CertificateResult.error("Error processing certificate: " + e.getMessage());
        }
    }
}
